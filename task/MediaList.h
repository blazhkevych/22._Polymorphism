#pragma once
#include "InformationCarrier.h"
class MediaList // Класс хранящий, массив объектов классов "USB", "HDD", "DVD".
{
	int m_size; // Количество объектов в массиве (размер массива).
	InformationCarrier** mediaList = new InformationCarrier * [m_size]; // Динамический массив указателей на базовый класс "InformationCarrier".
public:
	//TODO: Дописать конструкторы, деструктор проверить, дописать, как в 21 задании.
	// TODO: заглянуть в задание по вектору, матрице, возможно можно что-то потянуть.

	MediaList();
	~MediaList();
	void Print();
	void chan(int nomb);
	void dell(int nomb);
	void add();
	void rand__str();
	void search();
	void write();
	void read();
	// TODO: реализовать:
	/*
	* возможность	добавления устройства
	* удаления (по номеру), вывести список устройств пронумеровав и по i-тому удалить из массива.
	* печати (цикл фор, внутри одна строчка - полиморфизм) всего массива устройств и отдельно печать каждого вида устройств (использовать
	RTTI dynamic_cast либо type_id). Реализовать каку-то печать через dynamic_cast и что-то через type_id. 02,48,40
	* изменения (по	номеру) определённых параметров носителя. как в печати по і-тому елементу
	* поиска по	заданному критерию , по разным критериям поиск.
	*  а также возможность загрузки данных из	файла. Поле Наименование сохраняем первое, для понимая что мы вычитываем
	и создать пустой объект соотвествуючего класса, а потом дочитывать все остальное, вызвав на новосозжанном обьекте лоад,
	через виртуальный метод (полиморфизм) и	дописывать в новосозджанный объект данные.
	* сохранения данных в файл. через фор и для каждого устройства будет візіватся свой сейв через полиморфизм.
	Все примерно как делалось в 21-ом задании.
	* Методы печати, загрузки, сохранения - через полиморфизм.
	 */
};

